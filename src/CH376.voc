; ----------------------------------------------------------------------------
; Extensions pour le CH376

#ifdef WITH_CH376

#ifndef CH376_INC
#define CH376_INC
#echo "Ajout du vocabulaire CH376"


;---------------------------------------------------------------------------
;
; Adresse de l'interface CH376
;
;---------------------------------------------------------------------------
ch376_command = $341
ch376_data    = $340



;PREV_VOC_LINK = last_voc_link
;-last_voc_link = SOUNDS_LINK

; last_forth_word_nfa = HIMEM_nfa

CH376_nfa:
        .byte   $C5
        .byte   "CH37","6"+$80
; ----------------------------------------------------------------------------
        .word   last_forth_word_nfa
        .word   DODOES
        .word   DOVOC
        .word   CH376_voc
CH376_LINK:
;        .word   FORTH_LINK
        .word   last_voc_link

-last_voc_link = CH376_LINK
-last_forth_word_nfa = CH376_nfa

; ----------------------------------------------------------------------------
Pread_nfa:
        .byte $86
        .byte "(read",")"+$80
        .word FORTH_voc
Pread:
        .word *+2
.(
;(read):
	lda #$01
	jsr SETUP	; Récupère l'adresse
	stx _XSAVE	; Sauvegarde car détruit par WaitResponse
begin
	lda #$27	; ReadUSB
	sta ch376_command
	lda ch376_data
	sta N+2	; Nombre de caractères à lire
	beq fin
        ldy #$00	; Initialise Y (remarque: inutile la première fois)
loop:
	lda ch376_data
	sta (N),y
	iny
	dec N+2
	bne loop

	clc		; Calcule l'adresse du caractère suivant pour la prochaine boucle
	tya
	adc N
	sta N
	bcc suite
	inc N+1
suite:
	lda #$3b
	sta ch376_command
	lda #$22
	sta ch376_command
;	lda ch376_data
	jsr _WaitResponse
	cmp #$1d
	beq begin
fin
	ldx _XSAVE	; Restaure X
	jmp NEXT
.)

Pwrite_nfa:
        .byte $87
        .byte "(write",")"+$80
        .word Pread_nfa
Pwrite:
        .word *+2
.(
;(write):
	lda #$01
	jsr SETUP	; Récupère l'adresse
	stx _XSAVE	; Sauvegarde car détruit par WaitResponse
begin
	lda #$2d	; WriteRqData
	sta ch376_command
	lda ch376_data
	sta N+2	; Nombre de caractères à écrire
	beq fin
        ldy #$00	; Initialise Y (remarque: inutile la première fois)
loop:
	lda (N),y
	sta ch376_data
	iny
	dec N+2
	bne loop

	clc		; Calcule l'adresse du caractère suivant pour la prochaine boucle
	tya
	adc N
	sta N
	bcc suite
	inc N+1
suite:
	lda #$3d	; ByteWrGo
	sta ch376_command
	lda #$22
	sta ch376_command
;	lda ch376_data
	jsr _WaitResponse
	cmp #$1e
	beq begin
fin
	ldx _XSAVE	; Restaure X
	jmp NEXT
.)


_WaitResponse
.(
;---------------------------------------------------------------------------
; WaitResponse:
; A voir si il faut preserver X et Y
;
; Entree:
;
; Sortie:
; Z: 0 -> ACC: Status du CH376
; Z: 1 -> Timeout
; X,Y: Modifies
;---------------------------------------------------------------------------
; 25 Octets
;---------------------------------------------------------------------------
	LDY #$FF
ZZZ009
	LDX #$FF
ZZZ010
	LDA ch376_command
	BMI ZZZ011
	LDA #$22
	STA ch376_command
	LDA ch376_data
	RTS
ZZZ011
	DEX
	BNE ZZZ010
	DEY
	BNE ZZZ009
	RTS
.)

; ----------------------------------------------------------------------------
; : ch376:<BUILDS C, DOES> C@ 0341 C! 0340 C@ ;
;
ch376col_nfa:
        .byte $86
        .byte "ch376",":"+$80
        .word Pwrite_nfa
        .word DOCOL
        .word BUILDS
        .word CCOMMA
        .word DOES
DOch376col:
        .word CAT
        .word LIT
        .word ch376_command
        .word CSTORE
        .word LIT
        .word ch376_data
        .word CAT
        .word SEMIS

last_ch376_word_nfa = ch376col_nfa

; ----------------------------------------------------------------------------
; : CH376chk: <BUILDS SWAP C, C, DOES> DUP C@ 341 C!
;   ( GetStatus ) 22 341 C! 340 C@  SWAP 1+ C@ = ;
;
#if 0
ch376chkcol_nfa:
        .byte $89
        .byte "ch376chk",":"+$80
        .word last_ch376_word_nfa
        .word DOCOL
        .word BUILDS
        .word SWAP
        .word CCOMMA
        .word CCOMMA
        .word DOES
DOch376chkcol:
        .word DUP
        .word CAT
        .word LIT
        .word ch376_command
        .word CSTORE
#ifldef GetStatus
        .word GetStatus
#else
        .word LIT
        .word $22
        .word LIT
        .word $341
        .word CSTORE
        .word LIT
        .word ch376_data
        .word CAT
#endif
        .word SWAP
        .word ONEP
        .word CAT
        .word EQUAL
        .word SEMIS

-last_ch376_word_nfa = ch376chkcol_nfa
#endif

; ----------------------------------------------------------------------------
; : SetUSB 15 0341 C! 6 0340 C! 0340 C@ ;
; ( -- b )
SetUSB_nfa:
        .byte $86
        .byte "SetUS","B"+$80
        .word last_ch376_word_nfa
#ifdef CH376_FORTH
        .word DOCOL
        .word LIT
        .word $15
        .word LIT
        .word ch376_command
        .word CSTORE
        .word LIT
        .word 6
        .word LIT
        .word ch376_data
        .word CSTORE
        .word LIT
        .word ch376_data
        .word CAT
        .word SEMIS
#else
	.word *+2
	lda #$15
	sta ch376_command
	lda #$06
	sta ch376_data
	lda ch376_data
	jmp PUSH0A
#endif

; ----------------------------------------------------------------------------
; OLD:
; : SetFilename 2F 0341 C!   BL WORD HERE COUNT   0 DO DUP C@ 0340 C! 1+ LOOP DROP 0 0340 C! ;
;
; Utilisation: SetFilename FICHIER.FTH
;
; NEW:
; : SetFilename 2F 0341 C!   0518 0C -TRAILING    0 DO DUP C@ 0340 C! 1+ LOOP DROP 0 0340 C! ;
;
; Utilisation LIT" FORTH.DAT" SetFilename
;
SetFilename_nfa:
        .byte $8B
        .byte "SetFilenam","e"+$80
        .word SetUSB_nfa
SetFilename:
.(
        .word DOCOL
        .word LIT
        .word $2F
        .word LIT
        .word ch376_command
        .word CSTORE

#ifdef CH376_OLD
        .word BL
        .word WORD
        .word HERE
        .word COUNT
#else
	.word LIT
	.word $0518
	.word LIT
	.word $0C
	.word DTRAILING
#endif
        .word LIT
        .word $00
        .word PDO
ZZloop:
        .word DUP
        .word CAT
        .word LIT
        .word ch376_data
        .word CSTORE
        .word ONEP
        .word PLOOP
        .word ZZloop
        .word DROP
        .word LIT
        .word $00
        .word LIT
        .word ch376_data
        .word CSTORE
        .word SEMIS
.)

; ----------------------------------------------------------------------------
; 22 ch376: GetStatus
;
GetStatus_nfa:
        .byte $89
        .byte "GetStatu","s"+$80
        .word SetFilename_nfa
GetStatus:
        .word DODOES
        .word DOch376col
        .byte $22

; ----------------------------------------------------------------------------
; 31 ch376: Mount
;
Mount_nfa:
        .byte $85
        .byte "Moun","t"+$80
        .word GetStatus_nfa
        .word DODOES
        .word DOch376col
        .byte $31

; ----------------------------------------------------------------------------
; : SetByteRdWr 0341 C! 0100 /MOD SWAP 0340 C! 0340 C! GetStatus ;
;
SetByteRdWr_nfa
        .byte $8B
        .byte "SetByteRdW","r"+$80
        .word Mount_nfa
SetByteRdWr:
        .word DOCOL
;        .word LIT
;        .word $3A
        .word LIT
        .word ch376_command
        .word CSTORE
        .word LIT
        .word $0100
        .word SLMOD
        .word SWAP
        .word LIT
        .word ch376_data
        .word CSTORE
        .word LIT
        .word ch376_data
        .word CSTORE
        .word GetStatus
        .word SEMIS

; ----------------------------------------------------------------------------
; : SetByteLocate 39 0341 C! 0100 /MOD SWAP 0340 C! 0340 C! 0 0340 OVER OVER C! C! GetStatus ;
;
SetByteLocate_nfa
        .byte $8D
        .byte "SetByteLocat","e"+$80
        .word SetByteRdWr_nfa
SetByteLocate:
        .word DOCOL
        .word LIT
        .word $39
        .word LIT
        .word ch376_command
        .word CSTORE
        .word LIT
        .word $0100
        .word SLMOD
        .word SWAP
        .word LIT
        .word ch376_data
        .word CSTORE
        .word LIT
        .word ch376_data
        .word CSTORE
        .word LIT
        .word $00
        .word LIT
        .word ch376_data
        .word OVER
        .word OVER
        .word CSTORE
        .word CSTORE
        .word GetStatus
        .word SEMIS

; ----------------------------------------------------------------------------
; : FileOpen 32 0341 C! GetStatus ;
;
FileOpen_nfa
        .byte $88
        .byte "FileOpe","n"+$80
        .word SetByteLocate_nfa
FileOpen:
        .word DOCOL
        .word LIT
        .word $32
        .word LIT
        .word ch376_command
        .word CSTORE
        .word GetStatus

#ifndef CH376_OLD
;	0517 0548 C@ 1- 1 AND 0260 * 0B40 + 0D CMOVE ;
        .word LIT
        .word $517
	.word LIT
	.word $0548
	.word CAT
	.word ONES
	.word ONE
	.word ANDforth
	.word LIT
	.word $0260
	.word STAR
	.word LIT
	.word $0B40
	.word PLUS
	.word LIT
	.word $0D
	.word CMOVE
#endif
        .word SEMIS

-last_ch376_word_nfa = FileOpen_nfa
; ----------------------------------------------------------------------------
#ifdef WITH_AUTOSTART_SUPPORT
; : FileClose 36 0341 C! 0340 C! GetStatus ;
;
FileClose_nfa
        .byte $89
        .byte "FileClos","e"+$80
        .word last_ch376_word_nfa
FileClose:
        .word DOCOL
        .word LIT
        .word $36
        .word LIT
        .word ch376_command
        .word CSTORE
        .word LIT
        .word ch376_data
        .word CSTORE
        .word GetStatus
        .word SEMIS

-last_ch376_word_nfa = FileClose_nfa
#endif

; ----------------------------------------------------------------------------
; ( ad bloc -- 1 | ad 0 )
; : read B/BUF * SetByteLocate 14 = IF B/BUF 3A SetByteRdWr 1D = IF (read) 1 ELSE 0 THEN THEN ;
;
read_nfa:
        .byte $84
        .byte "rea","d"+$80
        .word last_ch376_word_nfa
read:
.(
        .word DOCOL
        .word B_BUF
        .word STAR
        .word SetByteLocate
        .word LIT
        .word $14
        .word EQUAL
        .word ZBRANCH
        .word ZZend
        .word B_BUF
        .word LIT
        .word $3A
        .word SetByteRdWr
        .word LIT
        .word $1D
        .word EQUAL
        .word ZBRANCH
        .word ZZelse
        .word Pread
        .word ONE
        .word BRANCH
        .word ZZend
ZZelse:
        .word ZERO
ZZend:
        .word SEMIS
.)

-last_ch376_word_nfa = read_nfa

; ----------------------------------------------------------------------------
#if 0
; : SetByteWrite 3C 0341 C! 0100 /MOD SWAP 0340 C! 0340 C! GetStatus ;
;
SetByteWrite_nfa
        .byte $8C
        .byte "SetByteWrit","e"+$80
        .word last_ch376_word_nfa
SetByteWrite:
        .word DOCOL
        .word LIT
        .word $3C
        .word LIT
        .word ch376_command
        .word CSTORE
        .word LIT
        .word $0100
        .word SLMOD
        .word SWAP
        .word LIT
        .word ch376_data
        .word CSTORE
        .word LIT
        .word ch376_data
        .word CSTORE
        .word GetStatus
        .word SEMIS

-last_ch376_word_nfa = SetByteWrite_nfa
#endif

; ----------------------------------------------------------------------------
; ( ad bloc -- 1 | ad 0 )
; : write B/BUF * SetByteLocate 14 = IF B/BUF 3C SetByteRdWr 14 = IF (write) 1 ELSE 0 THEN THEN ;
;
write_nfa:
        .byte $85
        .byte "writ","e"+$80
        .word last_ch376_word_nfa
write:
.(
        .word DOCOL
        .word B_BUF
        .word STAR
        .word SetByteLocate
        .word LIT
        .word $14
        .word EQUAL
        .word ZBRANCH
        .word ZZend
        .word B_BUF
        .word LIT
        .word $3C
        .word SetByteRdWr
        .word LIT
        .word $14
        .word EQUAL
        .word ZBRANCH
        .word ZZelse
        .word Pwrite
        .word ONE
        .word BRANCH
        .word ZZend
ZZelse:
        .word ZERO
ZZend:
        .word SEMIS
.)

-last_ch376_word_nfa = write_nfa

#ifdef CH376_Extended
; ----------------------------------------------------------------------------
; 1 ch376: GetVersion
;
GetVersion_nfa:
        .byte $8A
        .byte "GetVersio","n"+$80
        .word last_ch376_word_nfa
        .word DODOES
        .word DOch376col
        .byte $01

; ----------------------------------------------------------------------------
; : ByteRdGoB 0341 C! GetStatus ;
;
ByteRdGo_nfa
        .byte $88
        .byte "ByteRdG","o"+$80
        .word GetVersion_nfa
ByteRdGo:
        .word DOCOL
        .word LIT
        .word $3B
        .word LIT
        .word ch376_command
        .word CSTORE
        .word GetStatus
        .word SEMIS

; ----------------------------------------------------------------------------
; 27 ch376: ReadUSB
;
ReadUSB_nfa:
        .byte $87
        .byte "ReadUS","B"+$80
        .word ByteRdGo_nfa
        .word DODOES
        .word DOch376col
        .byte $27

-last_ch376_word_nfa = ReadUSB_nfa

#endif
; ----------------------------------------------------------------------------


; ----------------------------------------------------------------------------

; ----------------------------------------------------------------------------
; Pour support STARTUP / AUTOSTART
#ifdef WITH_AUTOSTART_SUPPORT
; : FILENAME COUNT DUP 0C > 89 ?ERROR 0518 SWAP OVER 0D BLANKS CMOVE ;
;
FILENAME_nfa:
	.byte $88
	.byte "FILENAM","E"+$80
	.word last_forth_word_nfa
FILENAME:
.(
        .word DOCOL
        .word COUNT
        .word DUP
        .word LIT
        .word $0C
        .word GREAT
        .word LIT
        .word $89
        .word QERROR
        .word LIT
        .word $0518
        .word SWAP
        .word OVER
        .word LIT
        .word $0D
        .word BLANKS
        .word CMOVE
        .word SEMIS
.)

-last_forth_word_nfa = FILENAME_nfa

; ----------------------------------------------------------------------------
; : ?FILE FILENAME CH376 SetFilename2 FileOpen 14 = IF 0 FileClose
;  DROP 1 ELSE 0 THEN ;

QFILE_nfa:
	.byte $85
	.byte "?FIL","E"+$80
	.word last_forth_word_nfa
QFILE:
.(
	.word DOCOL
        .word FILENAME
        .word SetFilename
        .word FileOpen
        .word LIT
        .word $14
        .word EQUAL
        .word ZBRANCH
        .word ZZelse
        .word ZERO
        .word FileClose
        .word DROP
        .word ONE
        .word BRANCH
        .word ZZend
ZZelse:
         .word ZERO
ZZend:
        .word SEMIS
.)

-last_forth_word_nfa = QFILE_nfa

; ----------------------------------------------------------------------------
; : (DOS) DUP XOPEN = IF DROP FileOpen = 0= 81
;       ELSE DROP 1 1C ;
;
; /?\ A définir comme DEFER (DOS)
PDOS_nfa:
	.byte $85
	.byte "(DOS",")"+$80
	.word last_forth_word_nfa
PDOS:
.(
        .word DOCOL
        .word DUP
        .word LIT
        .word XOPEN
        .word EQUAL
        .word ZBRANCH
        .word ZZelse
        .word DROP
        .word FileOpen
        .word LIT
        .word $14
        .word EQUAL
        .word ZEQUAL
        .word LIT
        .word $81
        .word BRANCH
        .word ZZend
ZZelse
        .word DROP
        .word ONE
        .word LIT
        .word $1c
ZZend
        .word SEMIS
.)


; ----------------------------------------------------------------------------
; DOS
;
DOS_nfa:
	.byte $83
	.byte "DO","S"+$80
	.word PDOS_nfa
DOS:
        .word DOCOL
        .word PDOS
        .word QERROR
        .word SEMIS

-last_forth_word_nfa = DOS_nfa
#endif

; ----------------------------------------------------------------------------
; ( bufad bloc r/w -- )
; Avec bloc >= 1 (/!\ Pas de vérification)
; : R/W IF 1- read 0= IF B/BUF BLANKS THEN ELSE 1- write . THEN ;
RSLW_nfa:
        .byte $83
        .byte "R/", "W"+$80
        .word last_forth_word_nfa
RSLW:
.(
        .word DOCOL
        .word ZBRANCH
        .word ZZelse
        .word ONES
        .word read
        .word ZEQUAL
        .word ZBRANCH
        .word ZZthen
        .word B_BUF
        .word BLANKS
ZZthen:
        .word BRANCH
        .word ZZend
ZZelse:
        .word ONES
        .word write
        .word DOT
ZZend:
        .word SEMIS
.)

-last_forth_word_nfa = RSLW_nfa

#else
#echo "Ajout entête du vocabulaire CH376"

CH376_voc = RAM_START-2+(*-DictInitTable)
        .byte   $81,$A0
        .word   last_ch376_word_nfa


#endif

#endif
