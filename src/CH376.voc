; ----------------------------------------------------------------------------
; Extensions pour le CH376

#ifdef WITH_CH376

#ifndef CH376_INC
#define CH376_INC
#echo "Ajout du vocabulaire CH376"


;---------------------------------------------------------------------------
;
; Adresse de l'interface CH376
;
;---------------------------------------------------------------------------
ch376_command = $341
ch376_data    = $340



;PREV_VOC_LINK = last_voc_link
;-last_voc_link = SOUNDS_LINK

; last_forth_word_nfa = HIMEM_nfa

CH376_nfa:
        .byte   $C5
        .byte   "CH37","6"+$80
; ----------------------------------------------------------------------------
        .word   last_forth_word_nfa
        .word   DODOES
        .word   DOVOC
        .word   CH376_voc
CH376_LINK:
;        .word   FORTH_LINK
        .word   last_voc_link

-last_voc_link = CH376_LINK
-last_forth_word_nfa = CH376_nfa

; ----------------------------------------------------------------------------
Pread_nfa:
        .byte $86
        .byte "(read",")"+$80
        .word FORTH_voc
Pread:
        .word *+2
.(
;(read):
	lda #$01
	jsr SETUP	; Récupère l'adresse
	stx _XSAVE	; Sauvegarde car détruit par WaitResponse
begin
	lda #$27	; ReadUSB
	sta ch376_command
	lda ch376_data
	sta N+2	; Nombre de caractères à lire
	beq fin
        ldy #$00	; Initialise Y (remarque: inutile la première fois)
loop:
	lda ch376_data
	sta (N),y
	iny
	dec N+2
	bne loop

	clc		; Calcule l'adresse du caractère suivant pour la prochaine boucle
	tya
	adc N
	sta N
	bcc suite
	inc N+1
suite:
	lda #$3b
	sta ch376_command
	lda #$22
	sta ch376_command
;	lda ch376_data
	jsr _WaitResponse
	cmp #$1d
	beq begin
fin
	ldx _XSAVE	; Restaure X
	jmp NEXT
.)

Pwrite_nfa:
        .byte $87
        .byte "(write",")"+$80
        .word Pread_nfa
Pwrite:
        .word *+2
.(
;(write):
	lda #$01
	jsr SETUP	; Récupère l'adresse
	stx _XSAVE	; Sauvegarde car détruit par WaitResponse
begin
	lda #$2d	; WriteRqData
	sta ch376_command
	lda ch376_data
	sta N+2	; Nombre de caractères à écrire
	beq fin
        ldy #$00	; Initialise Y (remarque: inutile la première fois)
loop:
	lda (N),y
	sta ch376_data
	iny
	dec N+2
	bne loop

	clc		; Calcule l'adresse du caractère suivant pour la prochaine boucle
	tya
	adc N
	sta N
	bcc suite
	inc N+1
suite:
	lda #$3d	; ByteWrGo
	sta ch376_command
	lda #$22
	sta ch376_command
;	lda ch376_data
	jsr _WaitResponse
	cmp #$1e
	beq begin
fin
	ldx _XSAVE	; Restaure X
	jmp NEXT
.)


_WaitResponse
.(
;---------------------------------------------------------------------------
; WaitResponse:
; A voir si il faut preserver X et Y
;
; Entree:
;
; Sortie:
; Z: 0 -> ACC: Status du CH376
; Z: 1 -> Timeout
; X,Y: Modifies
;---------------------------------------------------------------------------
; 25 Octets
;---------------------------------------------------------------------------
	LDY #$FF
ZZZ009
	LDX #$FF
ZZZ010
	LDA ch376_command
	BMI ZZZ011
	LDA #$22
	STA ch376_command
	LDA ch376_data
	RTS
ZZZ011
	DEX
	BNE ZZZ010
	DEY
	BNE ZZZ009
	RTS
.)

; ----------------------------------------------------------------------------
; : ch376:<BUILDS C, DOES> C@ 0341 C! 0340 C@ ;
;
ch376col_nfa:
        .byte $86
        .byte "ch376",":"+$80
        .word Pwrite_nfa
        .word DOCOL
        .word BUILDS
        .word CCOMMA
        .word DOES
DOch376col:
        .word CAT
        .word LIT
        .word ch376_command
        .word CSTORE
        .word LIT
        .word ch376_data
        .word CAT
        .word SEMIS

last_ch376_word_nfa = ch376col_nfa

; ----------------------------------------------------------------------------
; : CH376chk: <BUILDS SWAP C, C, DOES> DUP C@ 341 C!
;   ( GetStatus ) 22 341 C! 340 C@  SWAP 1+ C@ = ;
;
#if 0
ch376chkcol_nfa:
        .byte $89
        .byte "ch376chk",":"+$80
        .word last_ch376_word_nfa
        .word DOCOL
        .word BUILDS
        .word SWAP
        .word CCOMMA
        .word CCOMMA
        .word DOES
DOch376chkcol:
        .word DUP
        .word CAT
        .word LIT
        .word ch376_command
        .word CSTORE
#ifldef GetStatus
        .word GetStatus
#else
        .word LIT
        .word $22
        .word LIT
        .word $341
        .word CSTORE
        .word LIT
        .word ch376_data
        .word CAT
#endif
        .word SWAP
        .word ONEP
        .word CAT
        .word EQUAL
        .word SEMIS

-last_ch376_word_nfa = ch376chkcol_nfa
#endif

; ----------------------------------------------------------------------------
; : Exists 55 0341 C! 0340 C@ AA = ;
; ( -- b )
Exists_nfa:
        .byte $86
        .byte "Exist","s"+$80
        .word last_ch376_word_nfa
Exists
.(
        .word *+2
        lda #$06
        sta ch376_command
        lda #$00
        sta ch376_data
        ldy ch376_data
        cpy #$FF
        bne fin
        lda #$01
fin
        jmp PUSH0A
.)

-last_ch376_word_nfa = Exists_nfa

; ----------------------------------------------------------------------------
; : SetUSB 15 0341 C! 6 0340 C! 0340 C@ ;
; ( -- )
SetUSB_nfa:
        .byte $86
        .byte "SetUS","B"+$80
        .word last_ch376_word_nfa
#ifdef CH376_FORTH
SetUSB
        .word DOCOL
        .word LIT
        .word $15
        .word LIT
        .word ch376_command
        .word CSTORE
        .word LIT
        .word 6
        .word LIT
        .word ch376_data
        .word CSTORE
        .word LIT
        .word ch376_data
        .word CAT
        .word SEMIS
#else
SetUSB
	.word *+2
	lda #$15
	sta ch376_command
	lda #$06
	sta ch376_data
;	lda ch376_data
;	jmp PUSH0A
        jmp NEXT
#endif

; ----------------------------------------------------------------------------
; OLD:
; : SetFilename 2F 0341 C!   BL WORD HERE COUNT   0 DO DUP C@ 0340 C! 1+ LOOP DROP 0 0340 C! ;
;
; Utilisation: SetFilename FICHIER.FTH
;
; NEW:
; : SetFilename 2F 0341 C!   0518 0C -TRAILING    0 DO DUP C@ 0340 C! 1+ LOOP DROP 0 0340 C! ;
;
; Utilisation LIT" FORTH.DAT" SetFilename
;
SetFilename_nfa:
        .byte $8B
        .byte "SetFilenam","e"+$80
        .word SetUSB_nfa
SetFilename:
.(
        .word DOCOL
        .word LIT
        .word $2F
        .word LIT
        .word ch376_command
        .word CSTORE

#ifdef CH376_OLD
        .word BL
        .word WORD
        .word HERE
        .word COUNT
#else
	.word LIT
	.word $0518
	.word LIT
	.word $0C
	.word DTRAILING
#endif
        .word LIT
        .word $00
        .word PDO
ZZloop:
        .word DUP
        .word CAT
        .word LIT
        .word ch376_data
        .word CSTORE
        .word ONEP
        .word PLOOP
        .word ZZloop
        .word DROP
        .word LIT
        .word $00
        .word LIT
        .word ch376_data
        .word CSTORE
        .word SEMIS
.)

; ----------------------------------------------------------------------------
; 22 ch376: GetStatus
;
GetStatus_nfa:
        .byte $89
        .byte "GetStatu","s"+$80
        .word SetFilename_nfa
GetStatus:
        .word DODOES
        .word DOch376col
        .byte $22

; ----------------------------------------------------------------------------
; 31 ch376: Mount
;
Mount_nfa:
        .byte $85
        .byte "Moun","t"+$80
        .word GetStatus_nfa
Mount:
        .word DODOES
        .word DOch376col
        .byte $31

; ----------------------------------------------------------------------------
; : SetByteRdWr 0341 C! 0100 /MOD SWAP 0340 C! 0340 C! GetStatus ;
;
SetByteRdWr_nfa
        .byte $8B
        .byte "SetByteRdW","r"+$80
        .word Mount_nfa
SetByteRdWr:
        .word DOCOL
;        .word LIT
;        .word $3A
        .word LIT
        .word ch376_command
        .word CSTORE
        .word LIT
        .word $0100
        .word SLMOD
        .word SWAP
        .word LIT
        .word ch376_data
        .word CSTORE
        .word LIT
        .word ch376_data
        .word CSTORE
        .word GetStatus
        .word SEMIS

; ----------------------------------------------------------------------------
; : SetByteLocate 39 0341 C! 0100 /MOD SWAP 0340 C! 0340 C! 0 0340 OVER OVER C! C! GetStatus ;
;
SetByteLocate_nfa
        .byte $8D
        .byte "SetByteLocat","e"+$80
        .word SetByteRdWr_nfa
SetByteLocate:
        .word DOCOL
        .word LIT
        .word $39
        .word LIT
        .word ch376_command
        .word CSTORE
        .word LIT
        .word $0100
        .word SLMOD
        .word SWAP
        .word LIT
        .word ch376_data
        .word CSTORE
        .word LIT
        .word ch376_data
        .word CSTORE
        .word LIT
        .word $00
        .word LIT
        .word ch376_data
        .word OVER
        .word OVER
        .word CSTORE
        .word CSTORE
        .word GetStatus
        .word SEMIS

; ----------------------------------------------------------------------------
; : FileOpen 32 0341 C! GetStatus ;
;
FileOpen_nfa
        .byte $88
        .byte "FileOpe","n"+$80
        .word SetByteLocate_nfa
FileOpen:
        .word DOCOL
        .word LIT
        .word $32
        .word LIT
        .word ch376_command
        .word CSTORE
        .word GetStatus

#ifndef CH376_OLD
;	0517 0548 C@ 1- 1 AND 0260 * 0B40 + 0D CMOVE ;
        .word LIT
        .word $0517
	.word LIT
	.word $0548
	.word CAT
	.word ONES
	.word ONE
	.word ANDforth
	.word LIT
	.word $0260
	.word STAR
	.word LIT
	.word $0B40
	.word PLUS
	.word LIT
	.word $0D
	.word CMOVE
#endif
        .word SEMIS

-last_ch376_word_nfa = FileOpen_nfa
; ----------------------------------------------------------------------------
;#ifdef WITH_AUTOSTART_SUPPORT
#echo "Ajout du mot FileClose [CH376]"
; : FileClose 36 0341 C! 0340 C! GetStatus ;
;
FileClose_nfa
        .byte $89
        .byte "FileClos","e"+$80
        .word last_ch376_word_nfa
FileClose:
        .word DOCOL
        .word LIT
        .word $36
        .word LIT
        .word ch376_command
        .word CSTORE
        .word LIT
        .word ch376_data
        .word CSTORE
        .word GetStatus
        .word SEMIS

-last_ch376_word_nfa = FileClose_nfa
;#endif

; ----------------------------------------------------------------------------
; ( ad bloc -- 1 | ad 0 )
; : read B/BUF * SetByteLocate 14 = IF B/BUF 3A SetByteRdWr 1D = IF (read) 1 ELSE 0 THEN THEN ;
;
read_nfa:
        .byte $84
        .byte "rea","d"+$80
        .word last_ch376_word_nfa
read:
.(
        .word DOCOL
        .word B_BUF
        .word STAR
        .word SetByteLocate
        .word LIT
        .word $14
        .word EQUAL
        .word ZBRANCH
        .word ZZend
        .word B_BUF
        .word LIT
        .word $3A
        .word SetByteRdWr
        .word LIT
        .word $1D
        .word EQUAL
        .word ZBRANCH
        .word ZZelse
        .word Pread
        .word ONE
        .word BRANCH
        .word ZZend
ZZelse:
        .word ZERO
ZZend:
        .word SEMIS
.)

-last_ch376_word_nfa = read_nfa

; ----------------------------------------------------------------------------
#if 0
; : SetByteWrite 3C 0341 C! 0100 /MOD SWAP 0340 C! 0340 C! GetStatus ;
;
SetByteWrite_nfa
        .byte $8C
        .byte "SetByteWrit","e"+$80
        .word last_ch376_word_nfa
SetByteWrite:
        .word DOCOL
        .word LIT
        .word $3C
        .word LIT
        .word ch376_command
        .word CSTORE
        .word LIT
        .word $0100
        .word SLMOD
        .word SWAP
        .word LIT
        .word ch376_data
        .word CSTORE
        .word LIT
        .word ch376_data
        .word CSTORE
        .word GetStatus
        .word SEMIS

-last_ch376_word_nfa = SetByteWrite_nfa
#endif

; ----------------------------------------------------------------------------
; ( ad bloc -- 1 | ad 0 )
; : write B/BUF * SetByteLocate 14 = IF B/BUF 3C SetByteRdWr 14 = IF (write) 1 ELSE 0 THEN THEN ;
;
write_nfa:
        .byte $85
        .byte "writ","e"+$80
        .word last_ch376_word_nfa
write:
.(
        .word DOCOL
        .word B_BUF
        .word STAR
        .word SetByteLocate
        .word LIT
        .word $14
        .word EQUAL
        .word ZBRANCH
        .word ZZend
        .word B_BUF
        .word LIT
        .word $3C
        .word SetByteRdWr
        .word LIT
        .word $14
        .word EQUAL
        .word ZBRANCH
        .word ZZelse
        .word Pwrite
        .word ONE
        .word BRANCH
        .word ZZend
ZZelse:
        .word ZERO
ZZend:
        .word SEMIS
.)

-last_ch376_word_nfa = write_nfa

#ifdef CH376_Extended
#echo "Ajout des mots GetVersion, ByteRdGo, ReadUSB [CH376]"
; ----------------------------------------------------------------------------
; 1 ch376: GetVersion
;
GetVersion_nfa:
        .byte $8A
        .byte "GetVersio","n"+$80
        .word last_ch376_word_nfa
        .word DODOES
        .word DOch376col
        .byte $01

; ----------------------------------------------------------------------------
; : ByteRdGoB 0341 C! GetStatus ;
;
ByteRdGo_nfa
        .byte $88
        .byte "ByteRdG","o"+$80
        .word GetVersion_nfa
ByteRdGo:
        .word DOCOL
        .word LIT
        .word $3B
        .word LIT
        .word ch376_command
        .word CSTORE
        .word GetStatus
        .word SEMIS

; ----------------------------------------------------------------------------
; 27 ch376: ReadUSB
;
ReadUSB_nfa:
        .byte $87
        .byte "ReadUS","B"+$80
        .word ByteRdGo_nfa
        .word DODOES
        .word DOch376col
        .byte $27

-last_ch376_word_nfa = ReadUSB_nfa

#endif
; ----------------------------------------------------------------------------


; ----------------------------------------------------------------------------

; ----------------------------------------------------------------------------
; Pour support STARTUP / AUTOSTART
; #ifdef WITH_AUTOSTART_SUPPORT
; : FILENAME COUNT DUP 0C > 89 ?ERROR 0518 SWAP OVER 0D BLANKS CMOVE ;
;
FILENAME_nfa:
	.byte $88
	.byte "FILENAM","E"+$80
	.word last_forth_word_nfa
FILENAME:
.(
        .word DOCOL
        .word COUNT
        .word DUP
        .word LIT
        .word $0C
        .word GREAT
        .word LIT
        .word $89
        .word QERROR
        .word LIT
        .word $0518
        .word SWAP
        .word OVER
        .word LIT
        .word $0D
        .word BLANKS
        .word CMOVE
        .word SEMIS
.)

-last_forth_word_nfa = FILENAME_nfa

;
; Faire un FILENAME2 sans le COUNT pour pouvoir utiliser argv?
; ou supprimer le COUNT de FILENAME et ajouter un COUNT avant les appels à FILENAME?
;
;FILENAME2_nfa:
;	.byte $89
;	.byte "FILENAME","2"+$80
;	.word last_forth_word_nfa
;FILENAME:
;.(
;        .word DOCOL
;        .word BRANCH
;        .word FILENAME+4
;        .word SEMIS
;.)
;-last_forth_word_nfa = FILENAME2_nfa


; ----------------------------------------------------------------------------
; : ?FILE FILENAME CH376 SetFilename2 FileOpen 14 = IF 0 FileClose
;  DROP 1 ELSE 0 THEN ;

QFILE_nfa:
	.byte $85
	.byte "?FIL","E"+$80
	.word last_forth_word_nfa
QFILE:
.(
	.word DOCOL
        .word FILENAME
        .word SetFilename
        .word FileOpen
        .word LIT
        .word $14
        .word EQUAL
        .word ZBRANCH
        .word ZZelse
        .word ZERO
        .word FileClose
        .word DROP
        .word ONE
        .word BRANCH
        .word ZZend
ZZelse:
        .word ZERO
ZZend:
        .word SEMIS
.)

-last_forth_word_nfa = QFILE_nfa


; ----------------------------------------------------------------------------
;( argc -- adr len )
;( argc -- adr 0 ) si argc > nombre d'arguments
;
;/!\ Pas de vérification de la validité de argc (doit être >=0)
;: argv
;	1+ >R (Sauvegarde argc )
;
;	58F ( 590 1 - ) 0 0 1
;	R> 0
;	DO
;		DUP 0= IF ( Sortie prématurée, plus de paramètres )
;				LEAVE ( -- 59A 0 1 0 )
;			ELSE
;				SWAP DROP + + BL ENCLOSE
;			THEN
;	LOOP
;	IF >R + R> ELSE ( -- 59A 0 1 ) DROP  THEN ;
;
#ifdef WITH_ARGV
#echo "Ajout du mot ARGV";
ARGV_nfa:
        .byte   $84
        .byte   "ARG","V"+$80
; ----------------------------------------------------------------------------
        .word   last_forth_word_nfa
ARGV:
.(
        .word DOCOL
        .word ONEP
        .word TOR
        .word LIT
        .word $058F
        .word ZERO
        .word ZERO
        .word ONE
        .word RFROM
        .word ZERO
        .word PDO
L16A6
        .word DUP
        .word ZEQUAL
        .word ZBRANCH
        .word L16B4
        .word LEAVE
        .word BRANCH
        .word L16C0
L16B4
        .word SWAP
        .word DROP
        .word PLUS
        .word PLUS
        .word BL
        .word ENCLOSE
L16C0
        .word PLOOP
        .word L16A6
        .word ZBRANCH
        .word L16D2
        .word TOR
        .word PLUS
        .word RFROM
        .word BRANCH
        .word L16D4
L16D2
        .word DROP
L16D4
        .word SEMIS

.)

-last_forth_word_nfa = ARGV_nfa

#endif

; ----------------------------------------------------------------------------
#echo "Ajout du mot STARTUP avec suppport CH376";
STARTUP_nfa:
        .byte   $87
        .byte   "STARTU"
        .byte   $D0
; ----------------------------------------------------------------------------
        .word   last_forth_word_nfa
STARTUP:
.(
        .word   DOCOL
        .word   LIT
        .word   $60
        .word   ZERO
        .word   LIT
        .word   CallTel
        .word   TWOSTORE
        .word   LIT
        .word   v2dra
        .word   CAT
        .word   LIT
        .word   $07
        .word   ANDforth
        .word   LIT
        .word   vnmi
        .word   CSTORE
        .word   LIT
        .word   $04
        .word   PORIGIN
        .word   LIT
        .word   vnmi+1
        .word   STORE
;
        .word   Exists
        .word   ZEQUAL
;
        .word   ZBRANCH
        .word   LEA81
        .word   LIT
        .word   $88                                                             ; /?\ "Pas de STRATSED" à remplacer par: 8A->"Pas de lecteur"
        .word   MESSAGE
        .word   BRANCH
        .word   LEAFF
LEA81:
        .word   LIT
        .word   DOSBUFFERS
        .word   LIT
        .word   $07C0
        .word   ERASE
        .word   LIT
        .word   $02
        .word   LIT
        .word   nbfic
        .word   CSTORE
        .word   LIT
        .word   DOSBUFFERS
        .word   LIT
        .word   tampfc
        .word   STORE
        .word   ONE
        .word   LIT
        .word   ficnum
        .word   CSTORE
        .word   LIT
        .word   v2dra
        .word   CAT
        .word   LIT
        .word   $07
        .word   ANDforth
        .word   LIT
        .word   xfield
        .word   CSTORE

#ifdef WITH_AUTOSTART_SUPPORT
#echo "Ajout du support autostart (fichier: AUTOSTART_FILE)"

	.word SetUSB
	.word Mount
	.word DROP								; Modifier 'Mount' pour qu'il ne fasse pas le 340 C@
	.word GetStatus
	.word LIT
	.word $14
	.word EQUAL
	.word ZBRANCH
	.word LEAFF

#ifdef WITH_ARGV
;        2 argv DUP IF DUP HERE C! HERE 1+ SWAP CMOVE HERE ELSE 2DROP LIT" STARTUP.DAT" THEN ;
        .word TWO
        .word ARGV
        .word DUP
        .word ZBRANCH
        .word Largv_else
        .word DUP
        .word HERE
        .word CSTORE
        .word HERE
        .word ONEP
        .word SWAP
        .word CMOVE
        .word HERE
        .word BRANCH
        .word Largv_endif
Largv_else:
        .word TWODROP
#endif
        .word   PLITQ
; ----------------------------------------------------------------------------
.(

        .byte   end-*-1
        .byte   AUTOSTART_FILE
        end=*
.)
; ----------------------------------------------------------------------------
Largv_endif:
        .word   QFILE
        .word   ZBRANCH
        .word   LEAFF
        .word   LIT
        .word   $08
        .word   LIT
        .word   ftype
        .word   CSTORE
        .word   LIT
        .word   XOPEN
        .word   DOS
        .word   ZERO
        .word   BLK
        .word   STORE
        .word   LBRACKET
        .word   RPSTORE
        .word   ONE
        .word   LOAD
        .word   QUIT
#endif
LEAFF:
;        .word   LIT
;        .word   $8A
;        .word   MESSAGE
        .word   SEMIS
.)

-last_forth_word_nfa = STARTUP_nfa

;#ifdef CH376_Extended
#ifdef WITH_AUTOSTART_SUPPORT
#echo "Ajout des mots (DOS), DOS [CH376]"
; ----------------------------------------------------------------------------
; : (DOS) DUP XOPEN = IF DROP FileOpen 14 = 0= 81
;       ELSE DROP 1 1C ;
;
; Si on veut une compatibilité avec (DOS) du Stratsed:
; : (DOS) DUP XOPEN IF DROP FileOpen 14 = 1 *
;       ELSE DROP 8 ;
;
; /?\ A définir comme DEFER (DOS)
PDOS_nfa:
	.byte $85
	.byte "(DOS",")"+$80
	.word last_forth_word_nfa
PDOS:
.(
        .word DOCOL
        .word DUP
        .word LIT
        .word XOPEN
        .word EQUAL
        .word ZBRANCH
        .word ZZelse
        .word DROP
        .word FileOpen
        .word LIT
        .word $14
        .word EQUAL
        .word ZEQUAL
        .word LIT
        .word $81
        .word BRANCH
        .word ZZend
ZZelse
        .word DROP
        .word ONE
        .word LIT
        .word $1c
ZZend
        .word SEMIS
.)


; ----------------------------------------------------------------------------
; DOS
;
DOS_nfa:
	.byte $83
	.byte "DO","S"+$80
	.word PDOS_nfa
DOS:
        .word DOCOL
        .word PDOS
        .word QERROR
        .word SEMIS

-last_forth_word_nfa = DOS_nfa
#endif

; ----------------------------------------------------------------------------
; ( bufad bloc r/w -- )
; Avec bloc >= 1 (/!\ Pas de vérification)
; : R/W IF 1- read 0= IF B/BUF BLANKS THEN ELSE 1- write . THEN ;
RSLW_nfa:
        .byte $83
        .byte "R/", "W"+$80
        .word last_forth_word_nfa
RSLW:
.(
        .word DOCOL
        .word ZBRANCH
        .word ZZelse
        .word ONES
        .word read
        .word ZEQUAL
        .word ZBRANCH
        .word ZZthen
        .word B_BUF
        .word BLANKS
ZZthen:
        .word BRANCH
        .word ZZend
ZZelse:
        .word ONES
        .word write
        .word DOT
ZZend:
        .word SEMIS
.)

-last_forth_word_nfa = RSLW_nfa

; ------------------------------------------------------------------------------
;
; ------------------------------------------------------------------------------
;---------------------------------------------------------------------------
;
; Codes d'erreur du CH376
;
;---------------------------------------------------------------------------
#define SUCCESS $12
#define INT_SUCCESS $14
#define INT_DISK_READ $1D
#define INT_DISK_WRITE $1E
#define ABORT $5F

XLOAD_nfa:
        .byte $85
        .byte "XLOA","D"+$80
        .word last_ch376_word_nfa
XLOAD:
        .word *+2
.(
; Entrée: desalo contient l'adresse de chargement
; Sortie: 0 -> Ok, 2-> Erreur ($80+2-> Erreur Disque)
;         fisalo pointe sur l'octet suivant le dernier octet lu
;
; Faire 'FILENAME SetFilename FileOpen' avant l'appel à XLOAD
;
; : test BL WORD HERE FILENAME CH376 SetFilename FileOpen 014 = IF XLOAD ;
; ou
; : test BL WORD HERE ?FILE IF CH376 FileOpen DROP XLOAD ;
;
;  HEX 2000 052D ! test OVERLAY.SRC XLOAD
;
;
;    jsr _SetFilename
;    jsr _FileOpen
;    cmp #$14
;    bne Error
    lda #$ff
    tay
    jsr SetByteRead
    bne Error

    lda desalo
    sta $d0                                                                    ; /!\ Vérifier que $D0-D1 n'est pas utilisé
    lda desalo+1
    sta $d0+1

ZZ0002
    jsr ReadUSBData2
    bcs ReadNextChunk
    tya
    adc $d0
    sta $d0
    bcc ReadNextChunk
    inc $d0+1
ReadNextChunk
    jsr ByteRdGo
    beq ZZ0002
    jsr _FileClose
    lda $d0
    sta fisalo
    lda $d1
    sta fisalo+1
    lda #$00
    jmp PUSH0A

ReadUSBData2:
    stx _XSAVE
    sec
    lda #$27
    sta ch376_command
    ldx ch376_data
    beq ZZZ002
    ldy #$00
ZZZ003
    lda ch376_data
    sta ($d0),y
    iny
    dex
    bne ZZZ003
    clc
ZZZ002
    ldx _XSAVE
    rts

Error
    lda #$02
    jmp PUSH0A

-last_ch376_word_nfa = XLOAD_nfa


; ==============================================================================

;---------------------------------------------------------------------------
; 28 Octets
;---------------------------------------------------------------------------
_SetFilename
		; Copie la longueur de la chaine dans X
        stx _XSAVE
		tax

		lda #$2f
		sta ch376_command
;		sta ch376_data		; Pour ouverture de '/'
		ldy #$ff
ZZZ004
		iny
;		lda (bufnom+1),y
		lda bufnom+1,y
		sta ch376_data
;		dex
		bne ZZZ004

		; Ajoute le '\0' final
		lda #$00
		sta ch376_data
        ldx _XSAVE
		rts

;---------------------------------------------------------------------------
; 32 Octets
;---------------------------------------------------------------------------
_Mount
	LDA #$31
	.byte $2c

_FileOpen
	LDA #$32
	.byte $2c

_FileCreate
	LDA #$34

CH376_Cmd
	STA ch376_command

CH376_CmdWait
        stx _XSAVE
	JSR _WaitResponse
	ldx _XSAVE
	CMP #INT_SUCCESS
	RTS
;---------------------------------------------------------------------------
; ACC: Flag mise à jour (0: Non, 1: Oui)
_FileClose
	LDY #$36
	STY ch376_command
	STA ch376_data

	CLC									; Saut inconditionel
	BCC CH376_CmdWait


;---------------------------------------------------------------------------
; 28 Octets
;---------------------------------------------------------------------------
SetByteRead
	PHA
	LDA #$3A
	.byte $2c

SetByteWrite
	lda #$3C

CH376_Cmd2
	STA ch376_command
	PLA
	STA ch376_data
	STY ch376_data

CH376_CmdWait2
        stx _XSAVE
	JSR _WaitResponse
	ldx _XSAVE
	CMP #INT_DISK_READ
	RTS
;---------------------------------------------------------------------------
ByteRdGo
	LDA #$3B
	STA ch376_command
	BNE CH376_CmdWait2

.)
;---------------------------------------------------------------------------
#else
#echo "Ajout entête du vocabulaire CH376"

CH376_voc = RAM_START-2+(*-DictInitTable)
        .byte   $81,$A0
        .word   last_ch376_word_nfa


#endif

#endif

